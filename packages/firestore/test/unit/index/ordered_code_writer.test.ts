/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0x00 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0x00
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { expect } from 'chai';

import {
  numberOfLeadingZerosInByte,
  OrderedCodeWriter
} from '../../../src/index/ordered_code_writer';

class ValueTestCase<T> {
  constructor(
    readonly val: T,
    readonly ascEncoding: Uint8Array,
    readonly descEncoding: Uint8Array
  ) {}
}

const NUMBER_TEST_CASES: Array<ValueTestCase<number>> = [
  new ValueTestCase(
    Number.NEGATIVE_INFINITY,
    // Note: This values are taken from the Android reference implementation
    new Uint8Array([0x07, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
    new Uint8Array([0xf8, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
  ),
  new ValueTestCase(
    Number.MIN_SAFE_INTEGER,
    new Uint8Array([0x08, 0x3c, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0xc3, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    -2,
    new Uint8Array([0x08, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
    new Uint8Array([0xf7, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
  ),
  new ValueTestCase(
    -1,
    new Uint8Array([0x08, 0x40, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
    new Uint8Array([0xf7, 0xbf, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
  ),
  new ValueTestCase(
    -0.1,
    new Uint8Array([0x08, 0x40, 0x46, 0x66, 0x66, 0x66, 0x66, 0x66, 0x65]),
    new Uint8Array([0xf7, 0xbf, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9a])
  ),
  new ValueTestCase(
    -0.0,
    new Uint8Array([0x08, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
    new Uint8Array([0xf7, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
  ),
  new ValueTestCase(
    0,
    new Uint8Array([0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    Number.MIN_VALUE,
    new Uint8Array([0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]),
    new Uint8Array([0xf7, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe])
  ),
  new ValueTestCase(
    0.1,
    new Uint8Array([0x08, 0xbf, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9a]),
    new Uint8Array([0xf7, 0x40, 0x46, 0x66, 0x66, 0x66, 0x66, 0x66, 0x65])
  ),
  new ValueTestCase(
    1,
    new Uint8Array([0x08, 0xbf, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x40, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    2,
    new Uint8Array([0x08, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    4,
    new Uint8Array([0x08, 0xc0, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    8,
    new Uint8Array([0x08, 0xc0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    16,
    new Uint8Array([0x08, 0xc0, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    32,
    new Uint8Array([0x08, 0xc0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    64,
    new Uint8Array([0x08, 0xc0, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    128,
    new Uint8Array([0x08, 0xc0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    255,
    new Uint8Array([0x08, 0xc0, 0x6f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0x90, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    256,
    new Uint8Array([0x08, 0xc0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    257,
    new Uint8Array([0x08, 0xc0, 0x70, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0x8f, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    Number.MAX_SAFE_INTEGER,
    new Uint8Array([0x08, 0xc3, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
    new Uint8Array([0xf7, 0x3c, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
  ),
  new ValueTestCase(
    Number.POSITIVE_INFINITY,
    new Uint8Array([0x08, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    Number.NaN,
    new Uint8Array([0x08, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  )
];

const STRING_TEST_CASES: Array<ValueTestCase<string>> = [
  new ValueTestCase(
    '',
    new Uint8Array([0x00, 0x01]),
    new Uint8Array([0xff, 0xfe])
  ),
  new ValueTestCase(
    '\u0000',
    new Uint8Array([0x00, 0xff, 0x00, 0x01]),
    new Uint8Array([0xff, 0x00, 0xff, 0xfe])
  ),
  new ValueTestCase(
    '\u0000\u0000',
    new Uint8Array([0x00, 0xff, 0x00, 0xff, 0x00, 0x01]),
    new Uint8Array([0xff, 0x00, 0xff, 0x00, 0xff, 0xfe])
  ),
  new ValueTestCase(
    'abc',
    new Uint8Array([0x61, 0x62, 0x63, 0x00, 0x01]),
    new Uint8Array([0x9e, 0x9d, 0x9c, 0xff, 0xfe])
  ),
  new ValueTestCase(
    'xy¢z𠜎€𠜱あ𠝹',
    new Uint8Array([
      0x78, 0x79, 0xc2, 0xa2, 0x7a, 0xf0, 0xa0, 0x9c, 0x8e, 0xe2, 0x82, 0xac,
      0xf0, 0xa0, 0x9c, 0xb1, 0xe3, 0x81, 0x82, 0xf0, 0xa0, 0x9d, 0xb9, 0x00,
      0x01
    ]),
    new Uint8Array([
      0x87, 0x86, 0x3d, 0x5d, 0x85, 0x0f, 0x5f, 0x63, 0x71, 0x1d, 0x7d, 0x53,
      0x0f, 0x5f, 0x63, 0x4e, 0x1c, 0x7e, 0x7d, 0x0f, 0x5f, 0x62, 0x46, 0xff,
      0xfe
    ])
  ),
  new ValueTestCase(
    '¬˚ß∂∆ç',
    new Uint8Array([
      0xc2, 0xac, 0xcb, 0x9a, 0xc3, 0x9f, 0xe2, 0x88, 0x82, 0xe2, 0x88, 0x86,
      0xc3, 0xa7, 0x00, 0x01
    ]),
    new Uint8Array([
      0x3d, 0x53, 0x34, 0x65, 0x3c, 0x60, 0x1d, 0x77, 0x7d, 0x1d, 0x77, 0x79,
      0x3c, 0x58, 0xff, 0xfe
    ])
  ),
  new ValueTestCase(
    'œ∑´´ß™£',
    new Uint8Array([
      0xc5, 0x93, 0xe2, 0x88, 0x91, 0xc2, 0xb4, 0xc2, 0xb4, 0xc3, 0x9f, 0xe2,
      0x84, 0xa2, 0xc2, 0xa3, 0x00, 0x01
    ]),
    new Uint8Array([
      0x3a, 0x6c, 0x1d, 0x77, 0x6e, 0x3d, 0x4b, 0x3d, 0x4b, 0x3c, 0x60, 0x1d,
      0x7b, 0x5d, 0x3d, 0x5c, 0xff, 0xfe
    ])
  ),
  new ValueTestCase(
    'πåçasdlß¬µœ∑âsldalskdåßµ∂π',
    new Uint8Array([
      0xcf, 0x80, 0xc3, 0xa5, 0xc3, 0xa7, 0x61, 0x73, 0x64, 0x6c, 0xc3, 0x9f,
      0xc2, 0xac, 0xc2, 0xb5, 0xc5, 0x93, 0xe2, 0x88, 0x91, 0xc3, 0xa2, 0x73,
      0x6c, 0x64, 0x61, 0x6c, 0x73, 0x6b, 0x64, 0xc3, 0xa5, 0xc3, 0x9f, 0xc2,
      0xb5, 0xe2, 0x88, 0x82, 0xcf, 0x80, 0x00, 0x01
    ]),
    new Uint8Array([
      0x30, 0x7f, 0x3c, 0x5a, 0x3c, 0x58, 0x9e, 0x8c, 0x9b, 0x93, 0x3c, 0x60,
      0x3d, 0x53, 0x3d, 0x4a, 0x3a, 0x6c, 0x1d, 0x77, 0x6e, 0x3c, 0x5d, 0x8c,
      0x93, 0x9b, 0x9e, 0x93, 0x8c, 0x94, 0x9b, 0x3c, 0x5a, 0x3c, 0x60, 0x3d,
      0x4a, 0x1d, 0x77, 0x7d, 0x30, 0x7f, 0xff, 0xfe
    ])
  ),
  new ValueTestCase(
    '†¥¬´´`',
    new Uint8Array([
      0xe2, 0x80, 0xa0, 0xc2, 0xa5, 0xc2, 0xac, 0xc2, 0xb4, 0xc2, 0xb4, 0x60,
      0x00, 0x01
    ]),
    new Uint8Array([
      0x1d, 0x7f, 0x5f, 0x3d, 0x5a, 0x3d, 0x53, 0x3d, 0x4b, 0x3d, 0x4b, 0x9f,
      0xff, 0xfe
    ])
  )
];

describe('Ordered Code Writer', () => {
  it('computes number of leading zeros', () => {
    for (let i = 0; i < 0xff; ++i) {
      let zeros = 0;
      for (let bit = 7; bit >= 0; --bit) {
        if ((i & (1 << bit)) === 0) {
          ++zeros;
        } else {
          break;
        }
      }
      expect(numberOfLeadingZerosInByte(i)).to.equal(zeros, `for number ${i}`);
    }
  });

  it('converts numbers to bits', () => {
    verifyEncoding(NUMBER_TEST_CASES);
  });

  it('orders numbers correctly', () => {
    verifyOrdering(NUMBER_TEST_CASES);
  });

  it('converts strings to bits', () => {
    verifyEncoding(STRING_TEST_CASES);
  });

  it('orders strings correctly', () => {
    verifyOrdering(STRING_TEST_CASES);
  });

  function verifyEncoding(testCases: Array<ValueTestCase<unknown>>) : void {
    for (let i = 0; i < testCases.length; ++i) {
      const bytes = getBytes(testCases[i].val);
      expect(bytes.asc).to.deep.equal(
        testCases[i].ascEncoding,
        'Ascending for ' + testCases[i].val
      );
      expect(bytes.desc).to.deep.equal(
        testCases[i].descEncoding,
        'Descending for ' + testCases[i].val
      );
    }
  }

  function verifyOrdering(testCases: Array<ValueTestCase<unknown>>) : void {
    for (let i = 0; i < testCases.length; ++i) {
      for (let j = i; j < testCases.length; ++j) {
        const left = testCases[i].val;
        const leftBytes = getBytes(left);
        const right = testCases[j].val;
        const rightBytes = getBytes(right);
        expect(compare(leftBytes.asc, rightBytes.asc)).to.equal(
          i === j ? 0 : -1,
          `Ascending order: ${left} vs ${right}`
        );
        expect(compare(leftBytes.desc, rightBytes.desc)).to.equal(
          i === j ? 0 : 1,
          `Descending order: ${left} vs ${right}`
        );
      }
    }
  }
});

function compare(left: Uint8Array, right: Uint8Array): number {
  for (let i = 0; i < Math.min(left.length, right.length); ++i) {
    if (left[i] < right[i]) {
      return -1;
    }
    if (left[i] > right[i]) {
      return 1;
    }
  }
  return left.length - right.length;
}

function getBytes(val: unknown): { asc: Uint8Array; desc: Uint8Array } {
  const ascWriter = new OrderedCodeWriter();
  const descWriter = new OrderedCodeWriter();
  if (typeof val === 'number') {
    ascWriter.writeNumberAscending(val);
    descWriter.writeNumberDescending(val);
  } else if (typeof val === 'string') {
    ascWriter.writeUtf8Ascending(val);
    descWriter.writeUtf8Descending(val);
  } else {
    throw new Error('Encoding not yet supported for ' + val);
  }
  return { asc: ascWriter.encodedBytes(), desc: descWriter.encodedBytes() };
}
