/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0x00 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0x00
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { expect } from 'chai';

import {
  numberOfLeadingZerosInByte,
  OrderedCodeWriter
} from '../../../src/index/ordered_code_writer';

class ValueTestCase<T> {
  constructor(
    readonly val: T,
    readonly ascEncoding: Uint8Array,
    readonly descEncoding: Uint8Array
  ) {}
}

const NUMBER_TEST_CASES: Array<ValueTestCase<number>> = [
  new ValueTestCase(
    Number.NEGATIVE_INFINITY,
    // Note: This values are taken from the Android reference implementation
    new Uint8Array([0x07, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
    new Uint8Array([0xf8, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
  ),
  new ValueTestCase(
    Number.MIN_SAFE_INTEGER,
    new Uint8Array([0x08, 0x3c, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0xc3, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    -2,
    new Uint8Array([0x08, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
    new Uint8Array([0xf7, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
  ),
  new ValueTestCase(
    -1,
    new Uint8Array([0x08, 0x40, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
    new Uint8Array([0xf7, 0xbf, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
  ),
  new ValueTestCase(
    -0.1,
    new Uint8Array([0x08, 0x40, 0x46, 0x66, 0x66, 0x66, 0x66, 0x66, 0x65]),
    new Uint8Array([0xf7, 0xbf, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9a])
  ),
  new ValueTestCase(
    -0.0,
    new Uint8Array([0x08, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
    new Uint8Array([0xf7, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
  ),
  new ValueTestCase(
    0,
    new Uint8Array([0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    Number.MIN_VALUE,
    new Uint8Array([0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]),
    new Uint8Array([0xf7, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe])
  ),
  new ValueTestCase(
    0.1,
    new Uint8Array([0x08, 0xbf, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9a]),
    new Uint8Array([0xf7, 0x40, 0x46, 0x66, 0x66, 0x66, 0x66, 0x66, 0x65])
  ),
  new ValueTestCase(
    1,
    new Uint8Array([0x08, 0xbf, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x40, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    2,
    new Uint8Array([0x08, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    4,
    new Uint8Array([0x08, 0xc0, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    8,
    new Uint8Array([0x08, 0xc0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    16,
    new Uint8Array([0x08, 0xc0, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    32,
    new Uint8Array([0x08, 0xc0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    64,
    new Uint8Array([0x08, 0xc0, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    128,
    new Uint8Array([0x08, 0xc0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    255,
    new Uint8Array([0x08, 0xc0, 0x6f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0x90, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    256,
    new Uint8Array([0x08, 0xc0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    257,
    new Uint8Array([0x08, 0xc0, 0x70, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x3f, 0x8f, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    Number.MAX_SAFE_INTEGER,
    new Uint8Array([0x08, 0xc3, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
    new Uint8Array([0xf7, 0x3c, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
  ),
  new ValueTestCase(
    Number.POSITIVE_INFINITY,
    new Uint8Array([0x08, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  ),
  new ValueTestCase(
    Number.NaN,
    new Uint8Array([0x08, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    new Uint8Array([0xf7, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff])
  )
];

describe('Ordered Code Writer', () => {
  it('computes number of leading zeros', () => {
    for (let i = 0; i < 0xff; ++i) {
      let zeros = 0;
      for (let bit = 7; bit >= 0; --bit) {
        if ((i & (1 << bit)) === 0) {
          ++zeros;
        } else {
          break;
        }
      }
      expect(numberOfLeadingZerosInByte(i)).to.equal(zeros, `for number ${i}`);
    }
  });

  it('converts numbers to bits', () => {
    for (let i = 0; i < NUMBER_TEST_CASES.length; ++i) {
      const bytes = getBytes(NUMBER_TEST_CASES[i].val);
      expect(bytes.asc).to.deep.equal(
        NUMBER_TEST_CASES[i].ascEncoding,
        'Ascending for ' + NUMBER_TEST_CASES[i].val
      );
      expect(bytes.desc).to.deep.equal(
        NUMBER_TEST_CASES[i].descEncoding,
        'Descending for ' + NUMBER_TEST_CASES[i].val
      );
    }
  });

  it('orders numbers correctly', () => {
    for (let i = 0; i < NUMBER_TEST_CASES.length; ++i) {
      for (let j = i; j < NUMBER_TEST_CASES.length; ++j) {
        const left = NUMBER_TEST_CASES[i].val;
        const leftBytes = getBytes(left);
        const right = NUMBER_TEST_CASES[j].val;
        const rightBytes = getBytes(right);
        expect(compare(leftBytes.asc, rightBytes.asc)).to.equal(
          i === j ? 0 : -1,
          `Ascending order: ${left} vs ${right}`
        );
        expect(compare(leftBytes.desc, rightBytes.desc)).to.equal(
          i === j ? 0 : 1,
          `Descending order: ${left} vs ${right}`
        );
      }
    }
  });
});

function compare(left: Uint8Array, right: Uint8Array): number {
  for (let i = 0; i < Math.min(left.length, right.length); ++i) {
    if (left[i] < right[i]) {
      return -1;
    }
    if (left[i] > right[i]) {
      return 1;
    }
  }
  return left.length - right.length;
}

function getBytes(val: unknown): { asc: Uint8Array; desc: Uint8Array } {
  const ascWriter = new OrderedCodeWriter();
  const descWriter = new OrderedCodeWriter();
  if (typeof val === 'number') {
    ascWriter.writeNumberAscending(val);
    descWriter.writeNumberDescending(val);
  } else {
    throw new Error('Encoding not yet supported for ' + val);
  }
  return { asc: ascWriter.encodedBytes(), desc: descWriter.encodedBytes() };
}
